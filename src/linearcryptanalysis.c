#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "linearcryptanalysis.h"

#define N_PAIRS 100000 // Number of pairs necessary to break the cipher

/*
###############################################################################################
 Note that our target subkeys are K5,1 and K5,3. Thus, only the very last three bytes of the
 key matter for us.

 K5,1 = KEY[12] << 2
 K5,3 = ((KEY[13] & 0x0F) << 2) + (KEY[14] >> 6)


  Keys for testing
*/
byte KEY[15] = {78, 231, 58, 170, 218, 181, 240, 150, 252, 10, 22, 1, 223, 130, 97};        // Partial subkeys: 55, 9
// byte KEY[15] = {78, 231, 58, 170, 218, 181, 240, 150, 252, 10, 22, 1, 0, 130, 97};       // Partial subkeys: 0, 9
// byte KEY[15] = {78, 231, 58, 170, 218, 181, 240, 150, 252, 10, 22, 1, 0xFF, 0xFF, 0x00}; // Partial subkeys: 63, 60

// ############################################################################################


int main() {
    /* Generates pairs if there is not any */
    generate_pairs();

    /* Attacks the cipher present in pairs.dat file, generated by previous func */
    attack();

    return;
}

/*
    Performs a linear cryptanalysis attacks against the cipher present in
    pairs.dat file, generated previously.
*/
void attack() {
    byte k, kk; // target partial subkeys
    byte message[3], cipher[3];
    unsigned int plaintext, U_four;
    double count[64][64], max = -1.0, bias;
    byte k_max = 0xFF, kk_max = 0xFF;
    int i, pairs_n = N_PAIRS;

    // Bias of the expression = 0.00976562 or 5/512
    unsigned int P_MASK = 0x00800000; // P23
    unsigned int U_MASK = 0x00080880; // U4,19 + U4,11 + U4,7 (1<<19 | 1<<11 | 1<<7)

    byte *sbox_i = box_inv(SBOX, SBOX_LOOKUP_SIZE); // s-box inverse

    FILE *fi = fopen("pairs.dat", "r");

    // Zeroing counts
    memset(count, 0, 64*64*sizeof(double));
    // for (k=0; k<64; k++)
    //     for (kk=0; kk<64; kk++)
    //         count[k][kk] = 0;

    // Trying all partial subkeys
    for (k=0; k<64; k++) {
        for (kk=0; kk<64; kk++) {
             for (i=0; i < pairs_n; i++) {
                if (fread((void*)message, sizeof(byte), 3, fi) != 3)
                    perror("error reading plaintex");

                if (fread((void*)cipher, sizeof(byte), 3, fi) != 3)
                    perror("error reading ciphertext");

                // mount plaintext in a single uint
                plaintext = ((0x000000FF & message[0]) << 16) +
                            ((0x000000FF & message[1]) << 8) +
                            (0x000000FF & message[2]);

                // masks the bits of P
                plaintext &= P_MASK; // P23

                /*
                    Xoring Ciphertext with current partial subkeys

                     s1     s2     s3     s4
                    __|___ __|___ __|___ __|___
                    000000 000000 000000 000000
                    |_byte0_||_byte1_||_byte2_|

                */
                cipher[0] ^= (k<<2);   // xor-ing K5,1 for S-BOX4,1

                cipher[1] ^= (kk>>2);  // xor-ing K5,3 for S-BOX4,3
                cipher[2] ^= (kk<<6);  // xor-ing K5,3 for S-BOX4,3

                // running inverse substitution
                substitution(cipher, 0, sbox_i);

                // mount output in a single uint (U4 vector)
                U_four = ((0x000000FF & cipher[0]) << 16) +
                         ((0x000000FF & cipher[1]) << 8) +
                         (0x000000FF & cipher[2]);

                // masks the bits of U4
                U_four &= U_MASK; // U4,19 + U4,11 + U4,7

                // increments count if parity = 0
                if (!get_parity(plaintext ^ U_four))
                    count[k][kk]++;
            }
            rewind(fi); // rewind file

            // calculate bias for such pair
            bias = (count[k][kk] - pairs_n/2.0) / pairs_n*1.0;

            if (bias < 0) bias *= -1; // absolute value

            // keep track of the maximum bias key pair
            if (max < bias) {
                max = bias;
                k_max = k;
                kk_max = kk;
            }
        }
    }
    // prints result
    printf("\n### Partial subkeys:\nK5,1: %hhu\nK5,3: %hhu\n(bias: %f) ", k_max, kk_max, max);
}

/*
    Auxiliar function to generate pairs of plaintext and ciphertext.
    The function saves all pairs in binary format in a file called pairs.dat
*/
void generate_pairs() {
    byte msg[3] = {0, 0, 0};
    long y;
    unsigned int i,j,k;
    static char used[256][256][256];    // static so it does not overflow the stack
    FILE *fo = fopen("pairs.dat", "w");

    // zeroing array of used plaintexts
    for (i=0; i<256; i++)
        for (j=0; j<256; j++)
            for (k=0; k<256; k++)
                used[i][j][k] = 0;

    // generate N_PAIRS of pairs
    for (y=0; y < N_PAIRS; y++) {
        // generate random plaintext
        // used array avoids repetition of the same pairs
        do {
            i = (unsigned int)random_number() % 256;
            j = (unsigned int)random_number() % 256;
            k = (unsigned int)random_number() % 256;
        } while (used[i][j][k]);

        used[i][j][k] = 1; // set plaintext as used

        // builds plaintext message
        msg[0] = i;
        msg[1] = j;
        msg[2] = k;

        // write plaintext message to the file
        if (fwrite((void*)msg, sizeof(byte), 3, fo) != 3)
            perror("error writing plaintext");

        // encrypts the message
        spn(msg, 24, KEY, SBOX, PBOX);

        // write ciphertext to the file
        if (fwrite((void*)msg, sizeof(byte), 3, fo) != 3)
             perror("error writing ciphertext");
    }

    fclose(fo);
}


/*
    Auxiliar that generates a linear approximation table of 64x64 and
    prints it in the standard output. Needs to be called by main()
*/
void generate_approx_table() {
    char sbox_linear_approx[64][64];

    byte input, mask_input, mask_output;
    byte output, masked_input, masked_output;

    // initializing sbox_linear_approx
    memset(sbox_linear_approx, -32, 64*64);

    for (input=0; input < 64; input++) {
        output = SBOX[input];
        for (mask_input=0; mask_input < 64; mask_input++) {
            masked_input = input & mask_input;
            for (mask_output=0; mask_output < 64; mask_output++) {
                masked_output = output & mask_output;
                if (!get_parity(masked_input ^ masked_output))
                    sbox_linear_approx[mask_input][mask_output]++;
            }
        }
    }

    print_table_latex(sbox_linear_approx);
}

